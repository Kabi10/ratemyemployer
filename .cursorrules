# Cursor Master Rules for RateMyEmployer Project

## üîÑ Project Type Selection
- [X] Business Website
- [X] Web Application/SaaS Platform

## ‚ö†Ô∏è MANDATORY PRE-IMPLEMENTATION CHECKLIST ‚ö†Ô∏è
STOP! Before writing ANY code or suggesting ANY changes:

1. üîç SEARCH FIRST (REQUIRED):
   ```bash
   # Document ALL search results below
   grep_search "[feature keyword]" # Search for related functionality
   file_search "[filename pattern]" # Search for similar files
   list_dir "[relevant directory]" # List contents of relevant directories
   ```

2. üìù DOCUMENT FINDINGS (REQUIRED):
   ```markdown
   ## Existing Files Found:
   - [List all relevant files found with full paths]
   - [Include file sizes and last modified dates if relevant]
   
   ## Existing Functionality:
   - [Describe what already exists in detail]
   - [Note any patterns or architectural approaches used]
   
   ## Gaps Identified:
   - [List what's missing or needs enhancement]
   - [Identify technical debt or issues in existing code]
   
   ## Implementation Decision Tree:
   - Is there existing code that serves this purpose? [Yes/No]
   - Can existing code be enhanced to meet requirements? [Yes/No]
   - Is creating new code justified? [Yes/No, with reasoning]
   
   ## Proposed Approach:
   - [ ] Enhance existing code at [file path]
   - [ ] Create new files (requires detailed justification)
   - [ ] Refactor existing code at [file path]
   
   ## Implementation Plan:
   1. [First step with estimated effort]
   2. [Second step with estimated effort]
   3. [Additional steps as needed]
   ```

3. ‚úã WAIT FOR APPROVAL:
   - Present findings to user with clear options
   - Get explicit approval for chosen approach
   - Never proceed with new files if similar functionality exists
   - Document approval in the implementation plan

‚ùå IF YOU SKIP THIS CHECKLIST, YOU ARE VIOLATING THE MOST IMPORTANT RULE ‚ùå

## üìö AI Instructions

As an AI code builder, this document serves as your complete guide for building or extending the RateMyEmployer project. The rules below define HOW you should approach implementation:

1. **Decision Protocol**: Before implementing any feature:
   - First search for existing code and patterns
   - Show clear options with tradeoffs
   - Wait for explicit approval
   - Document your decision-making process

2. **Context Management**:
   - Maintain a mental map of the project architecture
   - Reference existing patterns when suggesting solutions
   - Track technical debt and refactoring opportunities
   - Keep your internal representation of the codebase updated

3. **Implementation Approach**:
   - Follow the pattern recognition guidelines
   - Use established project patterns over introducing new ones
   - Provide "why" explanations along with code
   - Tag all implementation decisions with appropriate decision factors

4. **Uncertainty Protocol**:
   - When encountering ambiguity, present options with pros/cons
   - Explicitly flag incomplete knowledge ("This appears to be ___, but I need more context")
   - Use specified formats for indicating uncertainty levels
   - Provide specific questions to resolve key uncertainties

5. **Documentation Protocol**:
   - All documentation is consolidated in central files
   - MCP documentation is in `MCP_DOCUMENTATION.md`
   - Form verification is documented in the MCP documentation
   - Use `npm run docs` to access the documentation helper
   - Never create new documentation files without checking existing ones
   - Update existing documentation rather than creating new files

## üß† RateMyEmployer Pattern Recognition Map

### Universal Code Structure Patterns
- **Server-Component Pattern**: `async function Page/Component({ params }) + await fetch/db` 
- **Client-Interactive Pattern**: `'use client'; useState/useEffect + event handlers`
- **Data-Fetch Pattern**: `getData` functions paired with React Server Components
- **Layout Pattern**: Hierarchical layouts with global elements in parent layouts
- **Review Pattern**: Form submission ‚Üí validation ‚Üí database storage ‚Üí display
- **Company Pattern**: Company profile ‚Üí reviews ‚Üí ratings ‚Üí statistics
- **Authentication Pattern**: Login/signup ‚Üí session management ‚Üí protected routes
- **Supabase Pattern**: Server-side client creation ‚Üí data fetching ‚Üí error handling
- **MCP Pattern**: Natural language query ‚Üí Supabase operation ‚Üí data display

### RateMyEmployer-Specific Implementation Patterns
- **Auth Flow Pattern**: Supabase auth ‚Üí session checking ‚Üí protected routes via middleware
- **Data Display Pattern**: Skeleton loading ‚Üí data fetch ‚Üí render with error boundaries
- **Form Pattern**: Zod schema ‚Üí React Hook Form ‚Üí Supabase mutation ‚Üí toast notification
- **Filter Pattern**: URL-based state ‚Üí server-side filtering ‚Üí paginated results
- **Rating Pattern**: User input ‚Üí calculation ‚Üí color-coded visual representation
- **News Integration Pattern**: SerpAPI fetch ‚Üí database storage ‚Üí component display
- **Company Search Pattern**: Debounced input ‚Üí Supabase query ‚Üí filtered results
- **Review Moderation Pattern**: Admin check ‚Üí status update ‚Üí notification
- **MCP Integration Pattern**: Setup ‚Üí schema definition ‚Üí stored procedures ‚Üí UI components

## üìä Project Progress Dashboard
Overall Progress: 60% Complete
- Setup & Configuration    ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†   100%
- Core Features           ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°   80%
- Admin Dashboard         ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°   40%
- User Features           ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°   50%
- Advanced Features       ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°   40%
- Testing & Deployment    ‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°   20%
- Post-Launch             ‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°   0%

## üîß RateMyEmployer Specific Rules

### Business Website & Web Application Features
- **Company Reviews System**: Implement with proper validation, moderation, and display
  - Use `ReviewForm.tsx` pattern with Zod validation and React Hook Form
  - Follow `ReviewCard.tsx` display pattern with rating visualization
  - Implement moderation with status enum (pending, approved, rejected)
  - Use toast notifications for user feedback

- **Rating Visualization**: Use consistent color-coded progress bars across the application
  - Red for ratings < 2.5
  - Yellow for ratings between 2.5 and 3.5
  - Green for ratings > 3.5
  - Use the StatCard component for consistent display

- **User Authentication**: Leverage Supabase for secure authentication and session management
  - Use middleware.ts pattern for route protection
  - Follow Auth.tsx component pattern for login/signup
  - Use role-based access control for admin features
  - Store user metadata in Supabase auth

- **Company Profiles**: Detailed company information with size, industry, and location data
  - Follow CompanyProfile.tsx pattern for display
  - Use CompanyForm.tsx pattern for data entry
  - Implement LocationAutocomplete.tsx for address input
  - Use industry enum for consistent categorization

- **Search and Filter**: Advanced search capabilities with multiple filter options
  - Use SearchAndFilter.tsx pattern with debounced input
  - Implement URL-based state for shareable filters
  - Follow CompanyList.tsx pagination pattern
  - Use Select components from UI library

- **Wall of Shame/Fame**: Highlight companies with lowest/highest ratings
  - Use shared `WallOfCompanies` component for both Wall of Fame and Wall of Shame
  - Implement enhanced filtering with industry, location, size, and rating range
  - Use tabbed interface for different data views
  - Display company statistics with visual indicators
  - Integrate news section with company cards
  - Use consistent color coding for ratings visualization

- **News Integration**: Fetch and display relevant company news
  - Use newsApi.ts pattern for external API calls
  - Follow CompanyNews.tsx display pattern
  - Implement caching strategy for API calls
  - Use error handling for failed requests

- **Admin Dashboard**: Moderation tools for reviews and company data
  - Follow role-based access pattern in middleware.ts
  - Use table patterns for data display
  - Implement action buttons for approve/reject
  - Add filtering and sorting capabilities

- **MCP Integration**: Natural language database interaction
  - Follow setup patterns in `scripts/setup-mcp.ts`
  - Use stored procedures from `scripts/mcp-stored-procedures.sql`
  - Implement UI components following `MCPDemoComponent.tsx` pattern
  - Use the interactive CLI in `scripts/run-mcp-server.js`
  - Ensure configuration files exist in `.mcp/supabase/` directory
  - Test functionality using the `/mcp-demo` page
  - Run the MCP server with `npm run mcp:start` before using MCP features
  - Use `npm run docs:mcp` to access comprehensive MCP documentation

- **Permission Management System**: Implement role-based access control for different parts of the application
  - Use `withAuth` HOC pattern for protecting components based on roles
  - Implement role hierarchy (admin > moderator > user)
  - Use middleware.ts for route protection at the page level
  - Create a dedicated permission-denied page for unauthorized access attempts
  - Use the AuthContext to manage and check user roles

## üéì RateMyEmployer Lessons

### üñ•Ô∏è UI/UX Implementation Patterns
- Use Shadcn UI components for consistent design
- Maintain consistent page layouts (p-6 padding, mb-8 header spacing)
- For loading states: use LoadingSpinner component and Suspense boundaries
- For forms: use React Hook Form with Zod validation and disable inputs during submission
- For filters/search: use useDebounce hook (300ms) and URL params for state
- For ratings: use StatCard component with consistent color schemes (red < 2.5, yellow 2.5-3.5, green > 3.5)
- For modals: use dialog component with aria attributes and focus management
- For animations: use Framer Motion with consistent durations (300-500ms)

### üîÑ Next.js Architecture Patterns
- Page props params must be typed as a Promise in Next.js 14+
- Use `createServerClient` from Supabase SSR for server components
- Mark components using `useRouter` or `useSearchParams` with `'use client'` directive
- Components using client-side hooks must be wrapped in Suspense
- When using dynamic imports with `next/dynamic`, set `ssr: false` for client-only components
- For client-side state: extract state display into client components
- Pass search params as props from server components instead of using hooks directly
- Handle auth properly: use middleware for protection, include callback URLs, use role-based access

### üß™ Testing Implementation Patterns
- Use Playwright for E2E tests with consistent selectors
- Always use `bcryptjs` instead of `bcrypt` in tests to avoid native dependencies
- When mocking API handlers, use inline functions instead of `.mockImplementation()`
- For dialog components, always provide `aria-describedby` attribute to avoid accessibility warnings
- Use `jest.spyOn` for functions that need to be restored after tests
- Mock Next.js hooks like `useRouter` at the module level with `jest.mock('next/navigation')`
- When mocking `useRouter`, use `jest.mocked(useRouter).mockReturnValue()` instead of casting
- Initialize mocks with default values for consistent behavior

### üõ†Ô∏è Process Implementation Requirements
- ALWAYS check for existing implementations before creating new files
- Use grep_search/file_search to look for similar file names and functionality
- Document search process in scratchpad before implementing features
- NEVER skip the pre-implementation checklist to avoid duplicate code
- Implement parallel components when dependencies allow
- Use consistent patterns across similar file types
- Create independent files first to avoid blocking dependencies
- Leverage existing templates and patterns when available
- Document implementation decisions for future reference
- Split implementation from deployment for faster iteration
- Consolidate documentation in central files rather than creating new ones

### üìÇ File Management and Cleanup Patterns
- Store SQL migrations in the `/supabase/migrations` directory with proper naming conventions
- Archive outdated schema dumps instead of keeping them in the root directory
- Maintain duplicate MCP procedure files in both `.mcp/supabase/procedures.sql` and `scripts/mcp-stored-procedures.sql`
- Use the `/archive` directory for files that might be needed for reference but are no longer actively used
- Remove temporary build artifacts and log files before committing
- Check for duplicate files by comparing file sizes, last modified dates, and content
- Use PowerShell commands for file comparison and cleanup on Windows environments
- Document all cleanup actions in commit messages for future reference
- Verify application functionality after cleanup operations
- Keep documentation files organized and up-to-date
- Regularly clean up temporary files to maintain a tidy codebase

### üîê Supabase Implementation Patterns
- Use `supabaseServer.ts` for server-side data fetching
- Use `supabaseClient.ts` for client-side operations
- Always wrap Supabase calls in try/catch blocks
- Use typed responses with Database types from schema.ts
- Follow the pattern in database.ts for consistent data access
- Use RLS policies for secure data access
- Implement proper error handling with DatabaseError type
- Use transactions for operations that modify multiple tables

### üîç Form Testing and Supabase Verification Patterns
- Always test form submissions with both valid and invalid data
- Implement client-side validation with Zod before submission
- Add server-side validation as a second layer of protection
- Use toast notifications to provide feedback on form submission status
- Log form submission attempts and results for debugging
- Verify data in Supabase after submission using the Table Editor
- Run SQL queries to check data integrity and relationships
- Create test scripts to automate verification of database state
- Test edge cases like minimum/maximum values and special characters
- Implement automated tests for critical form submissions
- Monitor form submission success rates and error patterns
- Verify that RLS policies are correctly enforcing access controls
- Check that timestamps and default values are correctly applied
- Validate that foreign key relationships are maintained
- Test form behavior under slow network conditions

### üîÆ MCP Implementation Patterns
- Use the consolidated documentation in `MCP_DOCUMENTATION.md`
- Follow the setup process in `scripts/setup-mcp.ts`
- Create stored procedures in `scripts/mcp-stored-procedures.sql`
- Use the interactive CLI in `scripts/run-mcp-server.js`
- Implement UI components following `MCPDemoComponent.tsx` pattern
- Use the demo page at `/mcp-demo` to showcase MCP integration
- Wrap Supabase calls in try/catch blocks with proper error handling
- Use the documentation helper with `npm run docs` for guidance
- Ensure the MCP server is running with `npm run mcp:start` before using MCP features
- Verify configuration files exist in `.mcp/supabase/config.json` and `.mcp/supabase/schema.json`
- Test stored procedures with `npm run mcp:sample-queries`
- Use dynamic imports with `{ ssr: false }` for MCP components to avoid SSR issues

### üîê Permission Management Patterns
- Use role hierarchy with clear precedence (admin > moderator > user)
- Implement `withAuth` HOC for component-level protection
- Use middleware for route-level protection
- Create dedicated permission denied page with clear messaging
- Store user roles in Supabase auth metadata
- Check permissions client-side for UI adjustments
- Check permissions server-side for data access control
- Use consistent error handling for unauthorized actions
- Implement role-based navigation visibility
- Cache permission checks where appropriate for performance

### üèÜ Wall of Shame/Fame Implementation Patterns
- Use shared components between Wall of Fame and Wall of Shame
- Implement enhanced filtering with multiple criteria
- Use tabs for industry-specific views
- Display statistics cards with visual indicators
- Integrate news section with company cards
- Use consistent color coding for ratings
- Implement responsive design for mobile viewing
- Use skeleton loading states for better UX
- Cache company data where appropriate
- Implement proper error handling and fallbacks

### üìã Review Moderation Implementation Patterns
- Track moderation history for audit purposes
- Add moderation notes for internal communication
- Implement bulk moderation actions for efficiency
- Use modals for detailed content viewing
- Implement filtering by moderation status
- Use consistent status indicators
- Notify users of moderation decisions
- Implement pagination for large datasets
- Use optimistic UI updates for better UX
- Implement proper error handling and recovery

## üìã Documentation Structure

### Main Documentation Files
- `README.md`: Main project documentation
- `MCP_DOCUMENTATION.md`: Comprehensive MCP integration documentation
- `CONTRIBUTING.md`: Guidelines for contributing to the project
- `SECURITY.md`: Security policy and guidelines
- `CODE_OF_CONDUCT.md`: Code of conduct for project contributors
- `CHANGELOG.md`: Project changelog

### Directory-Specific Documentation
- `scripts/README.md`: Documentation for utility scripts

### Documentation Access
- Use `npm run docs` to access the documentation helper
- Use `npm run docs:mcp` to open the MCP documentation directly

## üß© Implementation Templates

### Server Component Template
```tsx
export async function PageComponent({ 
  params,
  searchParams 
}: {
  params: { id: string },
  searchParams: { [key: string]: string | string[] | undefined }
}) {
  // Data fetching with Supabase
  const { data, error } = await getDataFromSupabase(params.id, searchParams);
  
  // Error handling
  if (error) {
    return <ErrorDisplay message={error.message} />;
  }
  
  if (!data) {
    return <ErrorDisplay message="Failed to load data" />;
  }
  
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-8">Page Title</h1>
      
      {/* Suspense boundary for client components */}
      <Suspense fallback={<LoadingSpinner />}>
        <ContentComponent data={data} />
      </Suspense>
    </div>
  );
}
```

### Client Component Template
```tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useDebounce } from '@/hooks/useDebounce';
import { useToast } from '@/components/ui/use-toast';

export default function InteractiveComponent({ 
  initialData,
  onDataChange 
}: ComponentProps) {
  // Local state
  const [data, setData] = useState(initialData);
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const { toast } = useToast();
  const debouncedValue = useDebounce(data, 300);
  
  // Event handlers
  const handleChange = (name: string, value: string) => {
    const newData = { ...data, [name]: value };
    setData(newData);
    
    // Update URL params
    const params = new URLSearchParams();
    Object.entries(newData).forEach(([key, value]) => {
      if (value) params.set(key, value);
    });
    
    router.push(`?${params.toString()}`);
    if (onDataChange) onDataChange(newData);
  };
  
  // Handle submission
  const handleSubmit = async () => {
    setIsLoading(true);
    try {
      // Supabase operation
      const { error } = await submitToSupabase(data);
      
      if (error) throw new Error(error.message);
      
      toast({
        title: "Success",
        description: "Operation completed successfully",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: error.message || "An error occurred",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <div className="space-y-4">
      {/* UI components */}
      <Button onClick={handleSubmit} disabled={isLoading}>
        {isLoading ? <LoadingSpinner /> : "Submit"}
      </Button>
    </div>
  );
}
```

### Review Component Template
```tsx
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useToast } from '@/components/ui/use-toast';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input';
import { LoadingSpinner } from '@/components/LoadingSpinner';
import { reviewSchema } from '@/lib/schemas';

type ReviewFormValues = z.infer<typeof reviewSchema>;

export function ReviewComponent({ 
  companyId,
  onSubmit 
}: {
  companyId: string;
  onSubmit: (data: ReviewFormValues) => Promise<void>;
}) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { toast } = useToast();
  
  const form = useForm<ReviewFormValues>({
    resolver: zodResolver(reviewSchema),
    defaultValues: {
      rating: 0,
      title: '',
      pros: '',
      cons: '',
      employment_status: 'current',
      position: '',
      location: '',
      salary: '',
      recommend: false,
      ceo_rating: 0,
    },
  });
  
  const handleSubmit = async (data: ReviewFormValues) => {
    setIsSubmitting(true);
    try {
      await onSubmit({
        ...data,
        companyId,
      });
      form.reset();
      toast({
        title: "Review Submitted",
        description: "Thank you for sharing your experience!",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: error.message || "Failed to submit review",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
      {/* Form fields */}
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? <LoadingSpinner /> : "Submit Review"}
      </Button>
    </form>
  );
}
```

### MCP Component Template
```tsx
'use client';

import { useState, useEffect } from 'react';
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import type { Database } from '@/types/supabase';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { LoadingSpinner } from '@/components/LoadingSpinner';

type MCPComponentProps = {
  title: string;
  description?: string;
  initialQuery?: string;
};

export default function MCPComponent({ 
  title,
  description,
  initialQuery 
}: MCPComponentProps) {
  const [data, setData] = useState<any[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  
  const supabase = createClientComponentClient<Database>();
  
  // Example function to fetch data using MCP-generated query
  const fetchData = async (query: string = initialQuery || '') => {
    if (!query) return;
    
    setLoading(true);
    setError(null);
    
    try {
      // This is where you would use the MCP-generated query
      // For example, if the query is "Show me all companies in the Technology industry"
      // MCP might generate something like:
      const { data, error } = await supabase
        .from('companies')
        .select('*')
        .eq('industry', 'Technology')
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      setData(data || []);
    } catch (err: any) {
      console.error('Error fetching data:', err);
      setError(err.message || 'An error occurred while fetching data');
    } finally {
      setLoading(false);
    }
  };
  
  // You can also use stored procedures created for MCP
  const executeStoredProcedure = async (procedureName: string, params?: Record<string, any>) => {
    setLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase.rpc(procedureName, params || {});
      
      if (error) throw error;
      setData(data || []);
    } catch (err: any) {
      console.error(`Error executing stored procedure ${procedureName}:`, err);
      setError(err.message || `An error occurred while executing ${procedureName}`);
    } finally {
      setLoading(false);
    }
  };
  
  // Optional: Execute initial query on component mount
  useEffect(() => {
    if (initialQuery) {
      fetchData();
    }
  }, [initialQuery]);
  
  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle>{title}</CardTitle>
        {description && <p className="text-sm text-gray-500">{description}</p>}
      </CardHeader>
      <CardContent>
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            <p>{error}</p>
          </div>
        )}
        
        <div className="space-y-4">
          {loading ? (
            <div className="flex justify-center py-8">
              <LoadingSpinner />
            </div>
          ) : data.length > 0 ? (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    {Object.keys(data[0]).map((key) => (
                      <th 
                        key={key}
                        className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                      >
                        {key}
                      </th>
                    ))}
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {data.map((item, index) => (
                    <tr key={index}>
                      {Object.values(item).map((value: any, i) => (
                        <td key={i} className="px-6 py-4 whitespace-nowrap">
                          {typeof value === 'object' ? JSON.stringify(value) : String(value)}
                        </td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          ) : (
            <p className="text-center py-8 text-gray-500">No data available</p>
          )}
        </div>
        
        <div className="mt-4 flex flex-wrap gap-2">
          <Button 
            onClick={() => executeStoredProcedure('get_average_ratings_by_industry')}
            variant="outline"
          >
            Average Ratings by Industry
          </Button>
          <Button 
            onClick={() => executeStoredProcedure('get_top_companies_by_industry', { industry_name: 'Technology' })}
            variant="outline"
          >
            Top Tech Companies
          </Button>
          <Button 
            onClick={() => executeStoredProcedure('get_recent_reviews_for_company', { company_id: 1 })}
            variant="outline"
          >
            Recent Reviews
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}
```

### Data Fetching Template
```tsx
// In lib/database.ts
export async function getData(
  filters: Record<string, string | string[] | undefined>
): Promise<DatabaseResult<T>> {
  try {
    const { search, industry, location, sort, page = '1', limit = '10' } = filters;
    
    // Build query
    let query = supabase
      .from('table')
      .select('*');
    
    // Apply filters
    if (search) {
      query = query.ilike('name', `%${search}%`);
    }
    
    if (industry) {
      query = query.eq('industry', industry);
    }
    
    if (location) {
      query = query.ilike('location', `%${location}%`);
    }
    
    // Apply sorting
    if (sort) {
      const [field, direction] = sort.toString().split('-');
      query = query.order(field, { ascending: direction === 'asc' });
    } else {
      query = query.order('created_at', { ascending: false });
    }
    
    // Apply pagination
    const pageNumber = parseInt(page.toString(), 10);
    const limitNumber = parseInt(limit.toString(), 10);
    const start = (pageNumber - 1) * limitNumber;
    
    query = query.range(start, start + limitNumber - 1);
    
    // Execute query
    const { data, error } = await query;
    
    if (error) {
      return {
        data: null,
        error: {
          message: error.message,
          details: error.details
        }
      };
    }
    
    return {
      data,
      error: null
    };
  } catch (error) {
    console.error("Failed to fetch data:", error);
    return {
      data: null,
      error: {
        message: error.message || "An unknown error occurred",
        details: error
      }
    };
  }
}
```

### Supabase Data Verification Script Template
```tsx
// scripts/verify-form-data.ts
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/supabase';
import dotenv from 'dotenv';
import { z } from 'zod';

// Load environment variables
dotenv.config();

// Initialize Supabase client with service role key for admin access
const supabase = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Define verification schemas (should match your form schemas)
const companyVerificationSchema = z.object({
  id: z.number(),
  name: z.string().min(2),
  industry: z.string(),
  location: z.string().min(1),
  created_at: z.string().datetime(),
  created_by: z.string().uuid(),
});

const reviewVerificationSchema = z.object({
  id: z.number(),
  company_id: z.number(),
  rating: z.number().min(1).max(5),
  title: z.string().min(1),
  pros: z.string().min(10),
  cons: z.string().min(10),
  created_at: z.string().datetime(),
  reviewer_id: z.string().uuid(),
});

// Verification functions
async function verifyCompanies() {
  console.log('üîç Verifying companies table...');
  
  const { data: companies, error } = await supabase
    .from('companies')
    .select('*')
    .order('created_at', { ascending: false })
    .limit(10);
  
  if (error) {
    console.error('‚ùå Error fetching companies:', error);
    return;
  }
  
  if (!companies || companies.length === 0) {
    console.log('‚ö†Ô∏è No companies found in the database');
    return;
  }
  
  console.log(`‚úÖ Found ${companies.length} companies`);
  
  // Validate each company against schema
  companies.forEach((company, index) => {
    try {
      companyVerificationSchema.parse(company);
      console.log(`‚úÖ Company #${index + 1} (${company.name}) is valid`);
    } catch (validationError) {
      console.error(`‚ùå Company #${index + 1} (${company.name}) validation failed:`, validationError);
    }
  });
  
  // Check for relationships
  console.log('üîç Checking company-review relationships...');
  
  for (const company of companies) {
    const { data: reviews, error: reviewError } = await supabase
      .from('reviews')
      .select('*')
      .eq('company_id', company.id)
      .limit(5);
    
    if (reviewError) {
      console.error(`‚ùå Error fetching reviews for company ${company.name}:`, reviewError);
      continue;
    }
    
    console.log(`‚úÖ Company ${company.name} has ${reviews?.length || 0} reviews`);
  }
}

async function verifyReviews() {
  console.log('üîç Verifying reviews table...');
  
  const { data: reviews, error } = await supabase
    .from('reviews')
    .select('*, companies(name)')
    .order('created_at', { ascending: false })
    .limit(10);
  
  if (error) {
    console.error('‚ùå Error fetching reviews:', error);
    return;
  }
  
  if (!reviews || reviews.length === 0) {
    console.log('‚ö†Ô∏è No reviews found in the database');
    return;
  }
  
  console.log(`‚úÖ Found ${reviews.length} reviews`);
  
  // Validate each review against schema
  reviews.forEach((review, index) => {
    try {
      // Extract the review data without the joined company
      const { companies, ...reviewData } = review;
      reviewVerificationSchema.parse(reviewData);
      console.log(`‚úÖ Review #${index + 1} for company ${companies?.name} is valid`);
    } catch (validationError) {
      console.error(`‚ùå Review #${index + 1} validation failed:`, validationError);
    }
  });
  
  // Check for data anomalies
  console.log('üîç Checking for data anomalies...');
  
  const { data: anomalies, error: anomalyError } = await supabase
    .from('reviews')
    .select('id, rating, company_id, companies(name)')
    .or('rating.lt.1,rating.gt.5');
  
  if (anomalyError) {
    console.error('‚ùå Error checking for anomalies:', anomalyError);
    return;
  }
  
  if (anomalies && anomalies.length > 0) {
    console.error(`‚ùå Found ${anomalies.length} reviews with invalid ratings:`, anomalies);
  } else {
    console.log('‚úÖ No rating anomalies found');
  }
}

// Run verification
async function runVerification() {
  console.log('üöÄ Starting database verification...');
  
  await verifyCompanies();
  await verifyReviews();
  
  console.log('‚úÖ Verification complete');
}

runVerification().catch(error => {
  console.error('‚ùå Verification failed:', error);
  process.exit(1);
});
